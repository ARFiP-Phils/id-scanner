<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARFP Verification</title>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cbor-js@0.1.0/cbor.min.js"></script>
    
    <style>
        body { font-family: 'Segoe UI', sans-serif; text-align: center; background: #f4f6f8; padding: 20px; color: #333; }
        .header-container { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); margin-bottom: 25px; }
        .org-logo { width: 80px; height: auto; margin-bottom: 10px; }
        h1 { font-size: 1.25rem; color: #004085; font-weight: 700; margin: 5px 0; }
        h2 { font-size: 0.9rem; color: #666; margin-top: 5px; text-transform: uppercase; }
        #canvas { width: 100%; max-width: 400px; display: none; border-radius: 8px; margin: 0 auto; border: 4px solid #333; }
        #status { margin-top: 15px; font-weight: bold; font-size: 1rem; min-height: 1.5em; }
        .btn-scan { padding: 12px 30px; font-size: 1rem; background: #0056b3; color: white; border: none; border-radius: 25px; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .card { background: white; max-width: 400px; margin: 20px auto; padding: 20px; border-radius: 12px; box-shadow: 0 10px 15px rgba(0,0,0,0.1); display: none; text-align: left; }
        .card h3 { text-align: center; margin-top: 0; padding-bottom: 10px; border-bottom: 2px solid #eee; }
        .row { display: flex; justify-content: space-between; margin-bottom: 12px; border-bottom: 1px solid #f0f0f0; padding-bottom: 5px; }
        .row strong { color: #333; } .row span { color: #888; font-size: 0.9rem; }
        #debugInfo { font-size: 0.7rem; color: #999; margin-top: 20px; word-break: break-all; display: none; }
    </style>
</head>
<body>

    <div class="header-container">
        <img src="logo.png" alt="ARFP Logo" class="org-logo" onerror="this.style.display='none'"> 
        <h1>Alliance of Registered Fisheries Professionals Inc.</h1>
        <h2>Official ID Verification</h2>
    </div>
    
    <button class="btn-scan" onclick="startScan()">üì∑ Scan ID Card</button>
    <br><br>
    <canvas id="canvas"></canvas>
    <div id="status">Ready to scan...</div>

    <div id="resultCard" class="card">
        <h3 id="verifyHeader">VERIFIED</h3>
        <div class="row"><span>Name:</span> <strong id="resName">-</strong></div>
        <div class="row"><span>Role:</span> <strong id="resRole">-</strong></div>
        <div class="row"><span>ID No:</span> <strong id="resID">-</strong></div>
        <div class="row"><span>Issuer:</span> <strong id="resIssuer">-</strong></div>
        <div id="debugInfo"></div>
    </div>

    <script>
        // --- 1. UTILITIES ---
        const B45_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
        const B45_MAP = {};
        for (let i = 0; i < B45_CHARSET.length; i++) B45_MAP[B45_CHARSET[i]] = i;

        function base45Decode(str) {
            const output = [];
            for (let i = 0; i < str.length; i += 3) {
                if (i + 1 >= str.length) break; 
                const c0 = B45_MAP[str[i]], c1 = B45_MAP[str[i + 1]], c2 = (i + 2 < str.length) ? B45_MAP[str[i + 2]] : null;
                if (c2 === null) output.push(c0 + (c1 * 45));
                else { const v = c0 + (c1 * 45) + (c2 * 45 * 45); output.push(v >> 8); output.push(v & 0xFF); }
            }
            return new Uint8Array(output);
        }

        function toBase64Url(uint8) {
            return btoa(String.fromCharCode(...uint8)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        }

        // Safe conversion to ArrayBuffer for CBOR.decode
        function decodeCBOR(view) {
            const cleanArray = new Uint8Array(view); // Copy to new typed array
            return CBOR.decode(cleanArray.buffer);   // Pass underlying ArrayBuffer
        }

        // Helper to extract clean bytes from a potential view
        function getBytes(view) {
            return new Uint8Array(view.buffer.slice(view.byteOffset, view.byteOffset + view.byteLength));
        }

        function getField(obj, key) {
            if (obj[key] !== undefined) return obj[key];
            if (obj[String(key)] !== undefined) return obj[String(key)];
            return null;
        }

        // --- 2. MANUAL SIGNATURE BUILDER ---
        function encodeBytes(data) {
            let prefix = [];
            let len = data.length;
            if (len < 24) prefix.push(0x40 | len);
            else if (len < 256) prefix.push(0x58, len);
            else if (len < 65536) prefix.push(0x59, (len >> 8) & 0xFF, len & 0xFF);
            else prefix.push(0x5A, (len >>> 24), (len >>> 16) & 0xFF, (len >>> 8) & 0xFF, len & 0xFF);
            const res = new Uint8Array(prefix.length + data.length);
            res.set(prefix); res.set(data, prefix.length);
            return res;
        }

        function createToBeSigned(protHeader, payload) {
            const sig1 = new Uint8Array([0x6A, 0x53, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 0x31]);
            const hBstr = encodeBytes(protHeader);
            const aBstr = new Uint8Array([0x40]); 
            const pBstr = encodeBytes(payload);
            
            const totalLen = 1 + sig1.length + hBstr.length + aBstr.length + pBstr.length;
            const res = new Uint8Array(totalLen);
            let offset = 0;
            res[offset++] = 0x84; 
            res.set(sig1, offset); offset += sig1.length;
            res.set(hBstr, offset); offset += hBstr.length;
            res.set(aBstr, offset); offset += aBstr.length;
            res.set(pBstr, offset);
            return res;
        }

        // --- 3. LOAD KEYS ---
        let publicKey = null;
        fetch('public_key.json').then(r => r.json()).then(jwk => {
            const x = base45Decode(jwk.x);
            const y = base45Decode(jwk.y);
            window.crypto.subtle.importKey(
                "jwk", { kty: "EC", crv: "P-256", x: toBase64Url(x), y: toBase64Url(y), ext: true },
                { name: "ECDSA", namedCurve: "P-256" }, true, ["verify"]
            ).then(key => { publicKey = key; console.log("Key Loaded"); })
             .catch(e => alert("Error: public_key.json missing."));
        });

        // --- 4. CAMERA ---
        const video = document.createElement("video");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const resultCard = document.getElementById("resultCard");

        function startScan() {
            resultCard.style.display = "none";
            document.getElementById("status").innerText = "Searching...";
            navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } }).then(stream => {
                video.srcObject = stream;
                video.setAttribute("playsinline", true);
                video.play();
                requestAnimationFrame(tick);
                canvas.style.display = "block";
            }).catch(err => alert("Camera Error: " + err));
        }

        function tick() {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                canvas.height = video.videoHeight;
                canvas.width = video.videoWidth;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const code = jsQR(imageData.data, imageData.width, imageData.height, { inversionAttempts: "dontInvert" });
                if (code) { processQR(code.data); return; }
            }
            requestAnimationFrame(tick);
        }

        // --- 5. VERIFICATION LOGIC ---
        async function processQR(qrString) {
            document.getElementById("status").innerText = "Verifying...";
            try {
                if (qrString.startsWith("HC1:")) qrString = qrString.substring(4);
                
                // 1. Inflate
                const compressed = base45Decode(qrString);
                const cwtBytes = pako.inflate(compressed);
                
                // 2. Decode COSE (Fix: Use decodeCBOR helper)
                let cose = decodeCBOR(cwtBytes);
                if (cose && typeof cose === 'object' && !Array.isArray(cose) && cose.tag === 18) cose = cose.value;
                
                // 3. Extract Headers & Payload
                // Note: cose[0] is protHeader, cose[2] is payload. Both are byte arrays.
                // We use getBytes to ensure we have a clean Uint8Array for the Signature Builder
                const protHeaderBytes = getBytes(cose[0]);
                const payloadBytes = getBytes(cose[2]);
                const signature = cose[3];

                // 4. Manually Reconstruct "To Be Signed" Bytes
                const ToBeSigned = createToBeSigned(protHeaderBytes, payloadBytes);

                if (!publicKey) { alert("Public Key not loaded."); return; }

                const valid = await window.crypto.subtle.verify(
                    { name: "ECDSA", hash: { name: "SHA-256" } },
                    publicKey, signature, ToBeSigned
                );

                // 5. Decode Payload (Fix: Use decodeCBOR helper)
                const data = decodeCBOR(payloadBytes);
                
                // Debug View
                document.getElementById("debugInfo").innerText = "RAW: " + JSON.stringify(data);

                if (valid) {
                    showResult(true, data);
                } else {
                    showResult(false, data);
                }

            } catch (err) {
                console.error(err);
                document.getElementById("status").innerText = "ERROR";
                alert("Scan Error: " + err.message);
                resultCard.style.display = "none";
            }
        }

        function showResult(isValid, data) {
            canvas.style.display = "none";
            video.pause();
            if(video.srcObject) video.srcObject.getTracks().forEach(track => track.stop());

            const card = document.getElementById("resultCard");
            const header = document.getElementById("verifyHeader");
            card.style.display = "block";
            
            let name = "Unknown";
            const rawName = getField(data, 7);
            if (rawName) {
                try {
                   if (typeof rawName === 'string' && !rawName.includes(" ")) {
                       const nameBytes = base45Decode(rawName); 
                       name = new TextDecoder().decode(nameBytes);
                   } else name = rawName;
                } catch(e) { name = rawName; }
            }

            const issuer = getField(data, 1) || "Unknown";
            const role = getField(data, "role") || "Unknown";
            const id = getField(data, "id") || "Unknown";

            document.getElementById("resName").innerText = name;
            document.getElementById("resIssuer").innerText = issuer;
            document.getElementById("resRole").innerText = role;
            document.getElementById("resID").innerText = id;

            if (isValid) {
                header.innerText = "‚úÖ AUTHENTICATED";
                header.style.color = "#28a745";
                card.style.border = "2px solid #28a745";
                document.getElementById("status").innerText = "Verification Successful";
            } else {
                header.innerText = "‚ùå COUNTERFEIT / INVALID SIG";
                header.style.color = "#dc3545";
                card.style.border = "4px solid #dc3545";
                document.getElementById("status").innerText = "‚ö†Ô∏è SIGNATURE MISMATCH";
            }
        }
    </script>
</body>
</html>
